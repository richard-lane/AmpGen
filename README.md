[![Build Status][travis-badge]][travis-link]
[![License: LGPL v3][license-badge]](./LICENSE)

<p align="center">
  <img src="https://github.com/GooFit/AmpGen/raw/master/doc/figs/logo.png">
</p>
AmpGen is a library and set of applications for fitting and generating multi-body particle decays using the isobar model.
It developed out of the MINT project used in the fitting of three and four-body pseudoscalar decays by the CLEO-c and LHCb colloborations. The library can handle the fitting and generation of a wide variety of final states, including those involving fermions and photons, as well as polarised initial states.

Source code for the evaluation of amplitudes is dynamically generated by a custom engine, JIT compiled and dynamically linked to the user programme at runtime, which results in high flexibility and performance.

## Table of Contents
* [Getting Started](#getting-started)
* [Applications](#applications)
* [Examples](#examples)
* [Advanced](#advanced)
* [API documentation](https://goofit.github.io/AmpGen/)
* [Acknowledgements](#acknowledgements)

## Getting started
### Installation
#### Getting the source
Clone with git
```
git clone http://github.com/GooFit/AmpGen/ --recursive
```
There is at the time of writing only a master branch (FIXME)

##### Build requirements:
* cmake >= 3.11.0
* C++ compiler with CXX standard >= 14 (gcc >= 4.9.3, clang ~ 5).
  Defaults to Cxx17 (enable cxx14 with cmake flag `-DCMAKE_CXX_STANDARD=14` )
* ROOT >= 6 with MathMore
  To (re)configure root with these options, use the additional command line options `-Dcxx14 -Dmathmore=ON` when configuring the installation of ROOT.

##### Optional:
* boost >= 1.67.0 for unit tests
* xROOTd for network file access
* OpenMP for multithreading
* ROOT >= 6 with MathMore and Minuit2 enabled. The external version of Minuit2 provided as an external package of GooFit is used if the ROOT version is not unavailable.
  To (re)configure root with these options, use the additional command line options `-Dcxx14 -Dminuit2=ON -Dmathmore=ON` when configuring the installation of ROOT.

#### Building
The configuration of the AmpGen build is performed by cmake.
It is recommended to use a build directory to keep the source tree clean.

```shell
mkdir build
cd build
cmake ..
make
```
This will build the shared library, several standalone test applications, and a set of unit tests.
Several examples of usages of the library are included in the apps directory and are built alongside the library.
All standalone programs can accept both options files and command line arguments.
They also support `--help` to print help for key arguments to the program.
This will also run the program, as arguments can be defined throughout each of the programs rather than all defined at the beginning.

#### Usage with ROOT

The library can be used interactively in conjunction with the ROOT C++ interpreter by adding the following lines
to the users root login script

```
  gSystem->Load("path_to_ampgen/build/lib/libAmpGen.so");
  gROOT->ProcessLine(".include path_to_ampgen");
```
##### LLVM
You can also build AmpGen with LLVM. The only change you might want when using Apple LLVM
is to specifically specify the location of the build tool for AmpGen's JIT:

```shell
-DAMPGEN_CXX=$(which c++)
```

##### LXPLUS

In order to build stand-alone on LXPLUS, you will need a valid development environment; the following line will work:

```shell
source /cvmfs/sft.cern.ch/lcg/views/setupViews.sh LCG_94python3 x86_64-centos7-gcc8-opt
```
The LCG versions and CMTCONFIG may need to be updated over time. 
The ROOT versions installed on cvmfs generally require C++17 support when building, i.e. when running cmake add the option `-DCMAKE_CXX_STANDARD=17`.

### Options files and decay descriptors
See the documentation on [Options Files](doc/man-options.md).


## Applications
This section details the prebuilt command line applications that use the AmpGen library for some common functionality, such as generating Toy Monte Carlo samples
and debugging amplitudes.

### Table of contents
* [Generator](#generator)
* [Debugger](#debugger)
* [ConvertToSourceCode](#converttosourcecode)

### Generator

The standalone generator for models can be used as

```shell
Generator MyOpts.opt --nEvents=10000 --Output=output.root
```

Which generates 10000 events of the model described in MyOpts.opt and saves them to output.root.
The output should include a tree (DalitzEventList) of candidates with the full four-vectors, as well as one- and two-dimensional projections, an example of which is shown below:

![s01](doc/figs/s01.png)

In particular, the tree indicates the way in which data is by default loaded into the _Event_ / _EventList_ class.
Several models for different  <img src="doc/figs/tex/fig2.png" style="margin-bottom:0px" />  decays published by the LHCb collaboration are included in the options directory. These options do not include EventTypes so as they can be included as part of a larger decay chain if required. For example, to generate  <img src="doc/figs/tex/fig3.png" style="margin-bottom:0px" />  toy  <img src="doc/figs/tex/fig4.png" style="margin-bottom:0px" />  events:

```
./Generator options/D02Kpipipi.opt --EventType "D0 K- pi+ pi+ pi-" --nEvents 1000000
```

### Debugger

The debugger application is a tool for producing verbose information debugging for amplitudes and models. It is used on an options file as
```
./Debugger MyOpts.opt
```
which calculates each amplitude at a randomly generated point in phase space, as well as calculating the total amplitude accounting for complex
couplings. Also computed is the amplitude for the P conjugate event. A more useful application is the _verbose_ debugging mode which can be
activated by
```
./Debugger MyOpts.opt --CoherentSum::Debug
```
which produces a large number of intermediate steps in the calculation of each amplitude, which are added to the calculation using the
ADD_DEBUG and ADD_DEBUG_TENSOR macros in the code generation. For example, in src/Lineshapes/BW.cpp.
(n.b), if the model is a PolarisedSum, i.e. handles spin in the initial/final state, the flag PolarisedSum::Debug should be used instead of CoherentSum::Debug, in order
to generate all of the intermediate calculations of the amplitude.  

### ConvertToSourceCode

This produces source code to evaluate the PDF, and normalises for use with other generators such as EvtGen, i.e. P(max) < 1. This can be used as
```shell
./ConvertToSourceCode MyOpts.opt --Output=MyFile.cpp
```
This can then be a compiled to a shared library using
```shell
g++ -Ofast -shared -rdynamic --std=c++14 -fPIC MyFile.cpp -o MyFile.so
```

## Examples

### SignalOnlyFitter

An example fitter is provided in _examples/SignalOnlyFitter.cpp_, which as the name suggests only has a single signal component in the fit.
The free parameters of the fit are specified in the same way as the Generator,
with the additional relevant slots being _DataSample_ which specifies the signal sample to fit,
which is presumed to already have the selection applied, and _Branches_ which takes a list of branch names,
and defaults to the format used by the Generator etc. More details can be found with
```
SignalOnlyFitter --help
```
For example, the fitter can be used to fit a toy MC sample generated by the generator by running:
```
Generator MyOpts.opt --nEvents 100000
SignalOnlyFitter MyOpts.opt --DataSample Generate_Output.root
```

## Advanced

This section contains miscellaneous details on more advanced functionality, including using python bindings and alternative parameterisation of the spin factors.

### Table of contents
* [Python Bindings](#python-bindings)
* [Quasi-Particles](#quasi-particles)

### Python Bindings
Models built into a shared library can be used in python using the following flags into ConvertToSourceCode:
```shell
./ConvertToSourceCode MyOpts.opt --Output=MyFile.cpp --OutputEvents=events.csv --IncludePythonBindings
```
where normalisation events are also output for testing purposes in events.csv.
This can then be used with the python bindings in ampgen.py:  
```python
from ampgen import FixedLib
model = FixedLib('MyModel.so')
print(model.matrix_elements[0]) # Print first matrix element

import pandas as pd
data = pd.read_csv('events.csv', nrows=100_000)
fcn1 = model.FCN_all(data)

# or, a bit slower, but just to show flexibility:
fcn2 = data.apply(model.FCN, axis=1)
```

### Quasi-Particles



## Acknowledgements
The development of this software has been  supported by the National Science Foundation under grant PHY-1414736 and through a subcontract under Cooperative Agreement OAC-1836650.   Any opinions, findings, and conclusions or recommendations expressed in this material are those of the developers and do not necessarily reflect the views of the National Science Foundation.

<p align="center">
  <div>
  <img src="https://github.com/GooFit/AmpGen/raw/master/doc/figs/UC_ID_PrimaryBlackRed.png">
  <img src="https://github.com/GooFit/AmpGen/raw/master/doc/figs/Iris-hep-3-regular-complete.png">
  <img src="https://github.com/GooFit/AmpGen/raw/master/doc/figs/NSF_4-Color_bitmap_Logo.png">
  </div>
</p>

[travis-badge]:      https://travis-ci.org/GooFit/AmpGen.svg?branch=master
[license-badge]:     https://img.shields.io/badge/License-GPL%20v2-blue.svg
[travis-link]:       https://travis-ci.org/GooFit/AmpGen

